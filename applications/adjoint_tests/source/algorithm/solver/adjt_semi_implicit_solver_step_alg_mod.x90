!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing adjoint test for semi_implicit_solver_alg_mod subroutine step

module adjt_semi_implicit_solver_step_alg_mod

  use constants_mod,                    only: i_def, r_def, l_def, r_solver
  use log_mod,                          only: log_event,         &
                                              log_scratch_space, &
                                              LOG_LEVEL_INFO,    &
                                              LOG_LEVEL_DEBUG,   &
                                              LOG_LEVEL_ERROR
  use field_mod,                        only: field_type
  use mesh_mod,                         only: mesh_type
  use derived_config_mod,               only: bundle_size
  use field_indices_mod,                only: isol_p, isol_u, isol_w, isol_uv, &
                                              igh_p, igh_t, igh_d, igh_u
  use io_config_mod,                    only: subroutine_timers
  use timer_mod,                        only: timer
  use finite_element_config_mod,        only: element_order_h, element_order_v
  use adj_semi_implicit_solver_alg_mod, only: adj_semi_implicit_solver_type
  use semi_implicit_solver_alg_mod,     only: semi_implicit_solver_alg_step
  use function_space_collection_mod,    only: function_space_collection
  use driver_modeldb_mod,               only: modeldb_type
  use fs_continuity_mod,                only: W2, W3, Wtheta
  use mr_indices_mod,                   only: nummr
  use si_operators_alg_mod,             only: compute_si_operators
  use operator_mod,                     only: operator_type
  use sci_enforce_bc_kernel_mod,        only: enforce_bc_kernel_type
  use model_clock_mod,                  only: model_clock_type
  use function_space_mod,               only: function_space_type
  use initial_theta_ref_kernel_mod,     only: initial_theta_ref_kernel_type
  use init_gungho_prognostics_alg_mod,  only: init_u_field,     &
                                              init_exner_field, &
                                              init_rho_field,   &
                                              init_mr_fields
  use field_array_mod,                  only: field_array_type
  use field_collection_mod,             only: field_collection_type
  use sci_geometric_constants_mod,      only: get_coordinates, &
                                              get_panel_id
  use idealised_config_mod,             only: test
  use sci_field_bundle_builtins_mod,    only: set_bundle_scalar
  use moist_dyn_factors_alg_mod,        only: moist_dyn_factors_alg

  implicit none

  private

  public  :: adjt_semi_implicit_solver_step_alg
  private :: adjt_semi_implicit_solver_step_alg_common

contains

  !> @brief Adjoint test for semi_implicit_solver_alg_mod subroutine step
  !> @details Does some setup, then calls the actual test via a private subroutine
  !!          twice with different flag values
  !> @param[in,out] modeldb     Structure containing the model state
  !> @param[in]     mesh        The model mesh
  !> @param[in]     model_clock The model clock
  subroutine adjt_semi_implicit_solver_step_alg( modeldb, mesh, model_clock )

    implicit none

    type(modeldb_type), target, intent(inout) :: modeldb
    type(mesh_type), pointer,   intent(in)    :: mesh
    type(model_clock_type),     intent(in)    :: model_clock

    ! Prognostic fields
    type(field_type), dimension(bundle_size) :: state
    type(field_type), dimension(bundle_size) :: rhs
    type(field_type)                         :: moist_dyn_gas_law
    type(field_type), dimension(nummr)       :: mr
    type(field_type), dimension(bundle_size) :: state_in
    type(field_type), dimension(bundle_size) :: rhs_in
    type(field_type)                         :: moist_dyn_gas_law_in
    type(field_type), dimension(nummr)       :: mr_in

    ! LS
    type(field_type), dimension(bundle_size) :: ls_rdef
    type(field_type),            pointer     :: ls_u
    type(field_type),            pointer     :: ls_rho
    type(field_type),            pointer     :: ls_theta
    type(field_type),            pointer     :: ls_exner
    type(field_type),            pointer     :: ls_mr(:)
    type(field_type),            pointer     :: ls_moist_dyn(:)
    type(field_collection_type), pointer     :: ls_fields
    type(field_collection_type), pointer     :: moisture_fields
    type(field_array_type),      pointer     :: ls_mr_array
    type(field_array_type),      pointer     :: ls_moist_dyn_array

    ! Variables for initialisation etc.
    type(adj_semi_implicit_solver_type) :: adj_semi_implicit_solver
    type(function_space_type), pointer  :: vector_space_wtheta_ptr
    type(function_space_type), pointer  :: vector_space_w2_ptr
    type(function_space_type), pointer  :: vector_space_w3_ptr
    type(field_type),          pointer  :: chi(:)
    type(field_type),          pointer  :: panel_id
    real(kind=r_def)                    :: initial_time
    integer(kind=i_def)                 :: i

    if (subroutine_timers) call timer('adjt_semi_implicit_solver_step_alg')

    ! --------------------------------------------------------------------------
    ! Setup
    ! --------------------------------------------------------------------------

    vector_space_wtheta_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, Wtheta )
    vector_space_w2_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W2 )
    vector_space_w3_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W3 )

    ! Perturbation
    call rhs(igh_u)%initialise(vector_space=vector_space_w2_ptr)
    call rhs(igh_t)%initialise(vector_space=vector_space_wtheta_ptr)
    call rhs(igh_d)%initialise(vector_space=vector_space_w3_ptr)
    call rhs(igh_p)%initialise(vector_space=vector_space_w3_ptr)

    call rhs(igh_u)%copy_field_properties(rhs_in(igh_u))
    call rhs(igh_t)%copy_field_properties(rhs_in(igh_t))
    call rhs(igh_d)%copy_field_properties(rhs_in(igh_d))
    call rhs(igh_p)%copy_field_properties(rhs_in(igh_p))

    call invoke( name="adjt_siss_1",                    &
                 setval_random(rhs(igh_u)),             &
                 setval_random(rhs(igh_t)),             &
                 setval_random(rhs(igh_p)),             &
                 setval_random(rhs(igh_d)),             &
                 enforce_bc_kernel_type(rhs(igh_u)),    &
                 setval_x( rhs_in(igh_u), rhs(igh_u) ), &
                 setval_x( rhs_in(igh_t), rhs(igh_t) ), &
                 setval_x( rhs_in(igh_p), rhs(igh_p) ), &
                 setval_x( rhs_in(igh_d), rhs(igh_d) ) )

    ! Input fields are r_def fields so preliminary work uses field_types
    call rhs(igh_u)%copy_field_properties(state(igh_u))
    call rhs(igh_t)%copy_field_properties(state(igh_t))
    call rhs(igh_d)%copy_field_properties(state(igh_d))
    call rhs(igh_p)%copy_field_properties(state(igh_p))

    call rhs(igh_u)%copy_field_properties(state_in(igh_u))
    call rhs(igh_t)%copy_field_properties(state_in(igh_t))
    call rhs(igh_d)%copy_field_properties(state_in(igh_d))
    call rhs(igh_p)%copy_field_properties(state_in(igh_p))

    call invoke( name="adjt_siss_2",                        &
                 setval_random(state(igh_u)),               &
                 setval_random(state(igh_t)),               &
                 setval_random(state(igh_p)),               &
                 setval_random(state(igh_d)),               &
                 enforce_bc_kernel_type(state(igh_u)),      &
                 setval_x( state_in(igh_u), state(igh_u) ), &
                 setval_x( state_in(igh_t), state(igh_t) ), &
                 setval_x( state_in(igh_p), state(igh_p) ), &
                 setval_x( state_in(igh_d), state(igh_d) ) )

    ! LS

    ls_fields => modeldb%fields%get_field_collection("prognostic_fields")

    call ls_fields%get_field( 'ls_theta', ls_theta )
    call ls_fields%get_field( 'ls_u', ls_u )
    call ls_fields%get_field( 'ls_rho', ls_rho )
    call ls_fields%get_field( 'ls_exner', ls_exner )

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field( "ls_mr", ls_mr_array )
    call moisture_fields%get_field( "ls_moist_dyn", ls_moist_dyn_array )
    ls_mr => ls_mr_array%bundle
    ls_moist_dyn => ls_moist_dyn_array%bundle

    chi => get_coordinates(ls_theta%get_mesh_id())
    panel_id => get_panel_id(ls_theta%get_mesh_id())

    ! Define reference field
    initial_time = 0.0_r_def
    call init_u_field( ls_u , initial_time )
    call set_bundle_scalar( 0.0_r_def, ls_mr, nummr )

    call invoke( name="adjt_siss_3", &
                 initial_theta_ref_kernel_type( ls_theta, chi, panel_id, test ) )

    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )
    call init_exner_field( ls_exner, ls_theta, ls_moist_dyn, initial_time )
    call init_rho_field( ls_rho, ls_theta, ls_exner, ls_moist_dyn, initial_time )
    call init_mr_fields( ls_mr, ls_theta, ls_exner, ls_rho, ls_moist_dyn )

    call invoke( name="adjt_siss_4", &
                 enforce_bc_kernel_type(ls_u) )

    call rhs(igh_u)%copy_field_properties(ls_rdef(igh_u))
    call rhs(igh_t)%copy_field_properties(ls_rdef(igh_t))
    call rhs(igh_d)%copy_field_properties(ls_rdef(igh_d))
    call rhs(igh_p)%copy_field_properties(ls_rdef(igh_p))

    call invoke( name="adjt_siss_5",                   &
                 setval_x( ls_rdef(igh_u), ls_u ),     &
                 setval_x( ls_rdef(igh_t), ls_theta ), &
                 setval_x( ls_rdef(igh_p), ls_exner ), &
                 setval_x( ls_rdef(igh_d), ls_rho ) )

    ! End LS

    call compute_si_operators( ls_rdef(igh_t), ls_rdef(igh_d), ls_rdef(igh_p), &
                               model_clock, ls_moist_dyn )
    call adj_semi_implicit_solver%initialise(rhs)

    ! Set up moist_dyn_gas_law & mr
    call moist_dyn_gas_law%initialise(vector_space=vector_space_wtheta_ptr)
    call moist_dyn_gas_law%copy_field_properties(moist_dyn_gas_law_in)

    do i = 1, nummr
      call mr(i)%initialise(vector_space=vector_space_wtheta_ptr)
      call mr(i)%copy_field_properties(mr_in(i))
      call invoke( name="adjt_siss_6",   &
                   setval_random(mr(i)), &
                   setval_x( mr_in(i), mr(i) ) )
    end do

    call invoke( name="adjt_siss_7",               &
                 setval_random(moist_dyn_gas_law), &
                 setval_x( moist_dyn_gas_law_in, moist_dyn_gas_law ) )

    ! End set up moist_dyn_gas_law & mr

    ! --------------------------------------------------------------------------
    ! Test with first_iteration = .true.
    ! --------------------------------------------------------------------------

    call adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                    state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                    adj_semi_implicit_solver, .true. )

    ! --------------------------------------------------------------------------
    ! Test with first_iteration = .false.
    ! --------------------------------------------------------------------------

    ! Reset values first
    do i = 1, nummr
      call invoke( name="adjt_siss_8", &
                   setval_x( mr(i), mr_in(i) ) )
    end do
    call invoke( name="adjt_siss_9",                                 &
                 setval_x( moist_dyn_gas_law, moist_dyn_gas_law_in ), &
                 setval_x( rhs(igh_u), rhs_in(igh_u) ),               &
                 setval_x( rhs(igh_t), rhs_in(igh_t) ),               &
                 setval_x( rhs(igh_p), rhs_in(igh_p) ),               &
                 setval_x( rhs(igh_d), rhs_in(igh_d) ),               &
                 setval_x( state(igh_u), state_in(igh_u) ),           &
                 setval_x( state(igh_t), state_in(igh_t) ),           &
                 setval_x( state(igh_p), state_in(igh_p) ),           &
                 setval_x( state(igh_d), state_in(igh_d) ) )

    call adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                    state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                    adj_semi_implicit_solver, .false. )

    call adj_semi_implicit_solver%finalise()

    if (subroutine_timers) call timer('adjt_semi_implicit_solver_step_alg')

  end subroutine adjt_semi_implicit_solver_step_alg

  !> @brief Actual code for adjoint test for semi_implicit_solver_alg_mod subroutine step
  !> @param[in,out] state                    Prognostic state
  !> @param[in,out] rhs                      Prognostic rhs
  !> @param[in,out] moist_dyn_gas_law        Prognostic moist_dyn_gas_law
  !> @param[in,out] mr                       Prognostic mr
  !> @param[in,out] state_in                 Input state
  !> @param[in,out] rhs_in                   Input rhs
  !> @param[in,out] moist_dyn_gas_law_in     Input moist_dyn_gas_law
  !> @param[in,out] mr_in                    Input mr
  !> @param[in,out] adj_semi_implicit_solver Adjoint semi-implicit solver
  !> @param[in]     first_iteration          Switch to control which test to do
  subroutine adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                        state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                        adj_semi_implicit_solver, first_iteration )

    implicit none

    ! Prognostic fields
    type(field_type), dimension(bundle_size), intent(inout) :: state
    type(field_type), dimension(bundle_size), intent(inout) :: rhs
    type(field_type), dimension(bundle_size), intent(inout) :: state_in
    type(field_type), dimension(bundle_size), intent(inout) :: rhs_in
    type(field_type),                         intent(inout) :: moist_dyn_gas_law
    type(field_type),                         intent(inout) :: moist_dyn_gas_law_in
    type(field_type), dimension(nummr),       intent(inout) :: mr
    type(field_type), dimension(nummr),       intent(inout) :: mr_in

    ! Solver
    type(adj_semi_implicit_solver_type), intent(inout) :: adj_semi_implicit_solver

    ! first_iteration switch
    logical(kind=l_def), intent(in) :: first_iteration

    ! Inner product test variables
    real(kind=r_def), parameter :: su_sf = 5.0e-19_r_def
    real(kind=r_def), parameter :: ru_sf = 1.0e7_r_def
    real(kind=r_def), parameter :: rt_sf = 1.0e22_r_def
    real(kind=r_def) :: ip_state(2,4), ip_rhs(2,4), ip_mr(2,nummr+1), inner1, inner2
    real(kind=r_def), parameter :: overall_tolerance = 1000.0_r_def
    real(kind=r_def) :: machine_tol, machine_tol_r_solver
    real(kind=r_def) :: relative_diff, relative_diff_r_solver

    integer(kind=i_def) :: i

    ! --------------------------------------------------------------------------
    ! Step the semi-implicit solver (i.e., forward code, Mx)
    ! --------------------------------------------------------------------------

    call semi_implicit_solver_alg_step( state, rhs, moist_dyn_gas_law, mr, &
                                        .false., first_iteration )

    ! --------------------------------------------------------------------------
    ! Compute <Mx,Mx>
    ! --------------------------------------------------------------------------

    do i = 1, nummr
      call invoke( name="adjt_siss_10", &
                   X_innerproduct_X( ip_mr(1,i), mr(i) ) )
    end do

    call invoke( name="adjt_siss_11",                                     &
                 X_innerproduct_X( ip_mr(1,nummr+1), moist_dyn_gas_law ), &
                 X_innerproduct_X( ip_state(1,1), state(igh_u) ),         &
                 X_innerproduct_X( ip_state(1,2), state(igh_t) ),         &
                 X_innerproduct_X( ip_state(1,3), state(igh_d) ),         &
                 X_innerproduct_X( ip_state(1,4), state(igh_p) ),         &
                 X_innerproduct_X( ip_rhs(1,1), rhs(igh_u) ),             &
                 X_innerproduct_X( ip_rhs(1,2), rhs(igh_t) ),             &
                 X_innerproduct_X( ip_rhs(1,3), rhs(igh_d) ),             &
                 X_innerproduct_X( ip_rhs(1,4), rhs(igh_p) ),             &

    ! Scaling factors
                 inc_a_times_x( su_sf, state(igh_u) ),                    &
                 inc_a_times_x( ru_sf, rhs(igh_u) ),                      &
                 inc_a_times_x( rt_sf, rhs(igh_t) ) )
    ip_state(1,1) = ip_state(1, 1) * su_sf
    ip_rhs(1,1) = ip_rhs(1, 1) * ru_sf
    ip_rhs(1,2) = ip_rhs(1, 2) * rt_sf

    inner1 = sum(ip_state(1,:)) + sum(ip_rhs(1,:)) + sum(ip_mr(1,:))

    ! For checking scaling factors
    write( log_scratch_space, * ) &
      'adjt_semi_implicit_solver_step_alg: first_iteration, state(u,t,d,p), rhs(u,t,d,p), mr, ip1=', &
      first_iteration, ip_state(1,:), ip_rhs(1,:), ip_mr(1,:)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! --------------------------------------------------------------------------
    ! Adjoint code
    ! --------------------------------------------------------------------------

    call adj_semi_implicit_solver%step( state, rhs, moist_dyn_gas_law, mr, &
                                        .false., first_iteration )

    ! --------------------------------------------------------------------------
    ! Compute <AMx,x>
    ! --------------------------------------------------------------------------

    do i = 1, nummr
      call invoke( name="adjt_siss_12", &
                   X_innerproduct_y( ip_mr(2,i), mr_in(i), mr(i) ) )
    end do

    call invoke( name="adjt_siss_13",                                                           &
                 X_innerproduct_y( ip_mr(2,nummr+1), moist_dyn_gas_law_in, moist_dyn_gas_law ), &
                 X_innerproduct_y( ip_state(2,1), state_in(igh_u), state(igh_u) ),              &
                 X_innerproduct_y( ip_state(2,2), state_in(igh_t), state(igh_t) ),              &
                 X_innerproduct_y( ip_state(2,3), state_in(igh_d), state(igh_d) ),              &
                 X_innerproduct_y( ip_state(2,4), state_in(igh_p), state(igh_p) ),              &
                 X_innerproduct_y( ip_rhs(2,1), rhs_in(igh_u), rhs(igh_u) ),                    &
                 X_innerproduct_y( ip_rhs(2,2), rhs_in(igh_t), rhs(igh_t) ),                    &
                 X_innerproduct_y( ip_rhs(2,3), rhs_in(igh_d), rhs(igh_d) ),                    &
                 X_innerproduct_y( ip_rhs(2,4), rhs_in(igh_p), rhs(igh_p) ) )

    inner2 = sum(ip_state(2,:)) + sum(ip_rhs(2,:)) + sum(ip_mr(2,:))

    ! Test the inner-product values for equality
    machine_tol = spacing( max( abs( inner1 ), abs( inner2 ) ) )
    relative_diff = abs( inner1 - inner2 ) / machine_tol
    machine_tol_r_solver = spacing( real( max( abs( inner1 ), abs( inner2 ) ), r_solver) )
    relative_diff_r_solver = abs( inner1 - inner2 ) / machine_tol_r_solver
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) &
        "PASSED semi_implicit_solver_alg_mod step, first_iteration=", first_iteration, inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    elseif ( relative_diff_r_solver < overall_tolerance ) then
      write( log_scratch_space, * ) &
        "PASSED (WITH PRECISION R_SOLVER BUT NOT R_DEF) semi_implicit_solver_alg_mod step, first_iteration=", &
        first_iteration, inner1, inner2, relative_diff_r_solver
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) &
        "FAILED semi_implicit_solver_alg_mod step, first_iteration=", first_iteration, inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine adjt_semi_implicit_solver_step_alg_common

end module adjt_semi_implicit_solver_step_alg_mod
